import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { formatPackSourceLabel, loadPackWithShards, readJsonFile } from './pack-loader.mjs'

const repoRoot = process.cwd()
const schemaPath = path.resolve(repoRoot, 'content', 'schemas', 'resource.schema.json')
const resourcePackPath = path.resolve(
  repoRoot,
  'content',
  'packs',
  'base',
  'resources',
  'resources.base.json',
)
const generatedRegistryPath = path.resolve(repoRoot, 'src', 'generated', 'registry', 'resources.ts')

function fail(message) {
  console.error(message)
  process.exit(1)
}

function validateResource(resource, index) {
  const prefix = `Resource[${index}]`
  if (!resource || typeof resource !== 'object') {
    fail(`${prefix}: expected object.`)
  }

  const id = typeof resource.id === 'string' ? resource.id.trim() : ''
  if (!id) {
    fail(`${prefix}: missing "id".`)
  }
  if (!/^[a-z][a-zA-Z0-9]*$/.test(id)) {
    fail(`${prefix}: id "${id}" must match ^[a-z][a-zA-Z0-9]*$.`)
  }

  const label = typeof resource.label === 'string' ? resource.label.trim() : ''
  if (!label) {
    fail(`${prefix}: missing "label".`)
  }

  const unit = typeof resource.unit === 'string' ? resource.unit.trim() : ''
  if (!unit) {
    fail(`${prefix}: missing "unit".`)
  }

  const description = typeof resource.description === 'string'
    ? resource.description.trim()
    : ''
  if (!description) {
    fail(`${prefix}: missing "description".`)
  }

  if (!resource.atomVector || typeof resource.atomVector !== 'object') {
    fail(`${prefix}: missing "atomVector".`)
  }

  const vector = resource.atomVector
  const symbols = ['H', 'C', 'O', 'Si', 'Fe']
  for (const symbol of symbols) {
    const value = Number(vector[symbol])
    if (!Number.isFinite(value) || value < 0) {
      fail(`${prefix}: atomVector.${symbol} must be a finite number >= 0.`)
    }
  }

  return {
    id,
    label,
    unit,
    description,
    atomVector: {
      H: Number(vector.H),
      C: Number(vector.C),
      O: Number(vector.O),
      Si: Number(vector.Si),
      Fe: Number(vector.Fe),
    },
  }
}

function validatePack(pack) {
  if (!pack || typeof pack !== 'object') {
    fail('Resource pack: expected top-level object.')
  }

  const packId = typeof pack.packId === 'string' ? pack.packId.trim() : ''
  if (!packId) {
    fail('Resource pack: "packId" is required.')
  }

  const version = Number(pack.version)
  if (!Number.isInteger(version) || version < 1) {
    fail('Resource pack: "version" must be an integer >= 1.')
  }

  if (!Array.isArray(pack.resources) || pack.resources.length === 0) {
    fail('Resource pack: "resources" must be a non-empty array.')
  }

  const resources = pack.resources.map(validateResource)
  const seenIds = new Set()
  for (const resource of resources) {
    if (seenIds.has(resource.id)) {
      fail(`Resource pack: duplicate resource id "${resource.id}".`)
    }

    seenIds.add(resource.id)
  }

  return {
    packId,
    version,
    resources,
  }
}

function buildRegistrySource(resourcePack, sourceLabel) {
  const resourceLiteral = JSON.stringify(resourcePack.resources, null, 2)

  return `// @generated by tools/content-build/build-resources-registry.mjs
// source: ${sourceLabel}

export type AtomSymbol = 'H' | 'C' | 'O' | 'Si' | 'Fe'

const resourceCatalogData = ${resourceLiteral} as const

export type ResourceId = typeof resourceCatalogData[number]['id']

export interface ResourceDefinition {
  id: ResourceId
  label: string
  unit: string
  description: string
}

export const resourceDefinitions: ResourceDefinition[] = resourceCatalogData.map((resource) => ({
  id: resource.id,
  label: resource.label,
  unit: resource.unit,
  description: resource.description,
}))

export const resourceById = resourceDefinitions.reduce<Record<ResourceId, ResourceDefinition>>((map, item) => {
  map[item.id] = item
  return map
}, {} as Record<ResourceId, ResourceDefinition>)

export const resourceIds = resourceDefinitions.map((item) => item.id)

export type AtomVector = Record<AtomSymbol, number>

export const atomVectors = resourceCatalogData.reduce<Record<ResourceId, AtomVector>>((map, resource) => {
  map[resource.id] = {
    H: Number(resource.atomVector.H),
    C: Number(resource.atomVector.C),
    O: Number(resource.atomVector.O),
    Si: Number(resource.atomVector.Si),
    Fe: Number(resource.atomVector.Fe),
  }
  return map
}, {} as Record<ResourceId, AtomVector>)

export interface AtomTotals {
  H: number
  C: number
  O: number
  Si: number
  Fe: number
}

export function zeroAtomTotals(): AtomTotals {
  return { H: 0, C: 0, O: 0, Si: 0, Fe: 0 }
}

export function computeAtomTotals(inventory: Partial<Record<ResourceId, number>>): AtomTotals {
  return resourceIds.reduce<AtomTotals>((totals, resourceId) => {
    const quantity = inventory[resourceId] ?? 0
    if (quantity === 0) {
      return totals
    }

    const vector = atomVectors[resourceId]
    totals.H += vector.H * quantity
    totals.C += vector.C * quantity
    totals.O += vector.O * quantity
    totals.Si += vector.Si * quantity
    totals.Fe += vector.Fe * quantity
    return totals
  }, zeroAtomTotals())
}

export function formatQty(value: number): string {
  if (Math.abs(value) >= 1000) {
    return value.toFixed(0)
  }

  if (Math.abs(value) >= 100) {
    return value.toFixed(1)
  }

  if (Math.abs(value) >= 10) {
    return value.toFixed(2)
  }

  return value.toFixed(3)
}
`
}

function main() {
  const checkMode = process.argv.includes('--check')
  const writeMode = process.argv.includes('--write')

  if (!existsSync(schemaPath)) {
    fail(`Missing schema: ${path.relative(repoRoot, schemaPath)}`)
  }
  if (!existsSync(resourcePackPath)) {
    fail(`Missing resource pack: ${path.relative(repoRoot, resourcePackPath)}`)
  }

  readJsonFile(schemaPath, repoRoot, fail)
  const loadedResourcePack = loadPackWithShards({
    repoRoot,
    basePackPath: resourcePackPath,
    entityKey: 'resources',
    fail,
  })
  const resourcePack = validatePack(loadedResourcePack.pack)
  const source = buildRegistrySource(
    resourcePack,
    formatPackSourceLabel(loadedResourcePack.sourceFiles, repoRoot),
  )

  if (writeMode) {
    mkdirSync(path.dirname(generatedRegistryPath), { recursive: true })
    writeFileSync(generatedRegistryPath, source, 'utf8')
    console.log(
      `Wrote ${path.relative(repoRoot, generatedRegistryPath)} (${resourcePack.resources.length} resources, ${loadedResourcePack.shardCount} shard(s)).`,
    )
    return
  }

  if (!checkMode) {
    console.log(`Validated resource pack (${resourcePack.resources.length} resources).`)
    return
  }

  if (!existsSync(generatedRegistryPath)) {
    fail(`Missing generated registry: ${path.relative(repoRoot, generatedRegistryPath)}. Run --write.`)
  }

  const current = readFileSync(generatedRegistryPath, 'utf8')
  if (current !== source) {
    fail(
      `Generated registry is stale: ${path.relative(repoRoot, generatedRegistryPath)}. Run "npm run content:build".`,
    )
  }

  console.log(
    `Content check passed: ${path.relative(repoRoot, generatedRegistryPath)} matches resource pack (${resourcePack.resources.length} resources, ${loadedResourcePack.shardCount} shard(s)).`,
  )
}

main()
